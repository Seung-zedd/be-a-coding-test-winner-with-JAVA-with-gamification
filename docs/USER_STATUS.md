# 🎮 용사 승전 기록 (User Status Deck) 🎮

이곳은 용사님의 눈부신 성장을 기록하는 전적판입니다.

---

### 👤 용사 프로필

- **칭호:** `코드 퀘스트 챌린저` (CodeQuest Challenger) ⚔️
- **현재 레벨:** Lv. 6 🆙 (상급 용사)
- **누적 XP:** 90 / 600 (다음 레벨까지 510 XP!)
- **특수 스킬:**
  - `단조 스택의 맹공` (Monotonic Stack: while문을 통한 선형 시간 정렬 파괴)
  - `수학적 귀납법의 눈` (절차를 수식으로 치환)
  - `정렬의 지휘봉` (Comparator 리턴값 및 복합 정렬 지휘)
  - `스트림 추출술` (Method Reference 데이터 추출)
  - `행간의 투시경` (지문의 요구사항을 주석으로 분해하여 설계도로 치환)
  - `양방향 교각 건설` (A→B, B→A 중복 경로 판별 논리)
  - `구조적 혜안` (자료구조의 성능 차이 분석을 통한 최적의 무기 선별)
  - `차원의 가교` (Dimensional Bridge: $c1=r2$ 조건을 통한 3중 루프의 논리적 완결 및 벡터 내적 전술)
  - `인덱스의 지배자` (Index Dominator: Row, Col 및 변칙적 인덱스를 자유자재로 조종)

---

### � 무한 수련의 방 (Repetition Mastery)

_Atomic Habits: "복습 주기를 1, 3, 7, 14, 30으로 기록한다."_

| 수련 과제 (주제)           | 현재 단계  | 진행 상태 (Counts)   | 다음 복습 예정일 |
| :------------------------- | :--------: | :------------------- | :--------------- |
| **모의고사 (완주)**        | **Master** | 🟢 🟢 🟢 🟢 🟢 (5/5) | **[정복 완료]**  |
| **행렬의 곱셈**            | **Master** | 🟢 🟢 🟢 🟢 🟢 (5/5) | **[정복 완료]**  |
| **크레인 인형 뽑기**       |   Lv. 1    | 🟢 ⚪ ⚪ ⚪ ⚪ (1/5) | 2026-02-22       |
| **괄호 회전하기**          |   Lv. 3    | 🟢 🟢 🟢 ⚪ ⚪ (3/5) | 2026-02-23       |
| **주식가격 & Daily Temps** |   Lv. 2    | 🟢 🟢 ⚪ ⚪ ⚪ (2/5) | 2026-02-23       |
| **프로세스 (우선순위 큐)** | **Master** | 🟢 🟢 🟢 🟢 🟢 (5/5) | **[정복 완료]**  |

---

### 🗺️ 던전 공략 기록 (Quest Log)

| 날짜       | 던전 이름 (문제)                       | 랭크  | 획득 XP | 비고                                                            |
| :--------- | :------------------------------------- | :---: | :-----: | :-------------------------------------------------------------- |
| 2026-02-21 | Crane Claw Machine (크레인 인형 뽑기)  | **S** |   +50   | **[정복]** 긴 지문을 파훼하는 시각화 및 분할 전술의 승리        |
| 2026-02-20 | Matrix Multiplication (행렬의 곱셈)    | **S** |   +70   | **[정복]** 수학적 귀납법을 통한 $O(N^3)$ 로직 완벽 구현         |
| 2026-02-19 | Mock Test (모의고사)                   | **A** |   +30   | **[마스터]** 해시맵을 활용한 구조적 혁신 및 O(N) 상수 분석 성공 |
| 2026-02-18 | Rotation Parentheses (괄호 회전하기)   | **A** |   +30   | **[복습]** 연산자 우선순위의 함정 파쇄 및 올바른 문자열 회전    |
| 2026-02-17 | Next Greater Element (뒤에 있는 큰 수) | **S** |   +50   | **[정복]** 단조 스택을 활용한 $O(N)$ 뒷 큰수 탐색               |
| 2026-02-17 | Correct Parentheses (올바른 괄호)      | **S** |   +20   | **[정복]** 스택 기본 예외 처리 및 최종 empty 검증               |
| 2026-02-16 | Stock Prices (주식 가격)               | **S** |   +70   | **[정복]** 스택 기반 가격 낙하 시점 역추적                      |
| 2026-02-15 | Visit Length (방문 길이)               | **S** |   +70   | **[정복]** 양방향 경로 중복 제거 및 경계 처리                   |
| 2026-02-14 | Failure Rate (실패율)                  | **S** |   +70   | **[정복]** O(M+N) 집계 및 복합 정렬 문법 파훼                   |
| 2026-02-11 | Dimensional Rifts (n^2 배열 자르기)    | **S** |   +50   | **[정복]** 완벽한 논리적 이해 및 오프셋 함정 파훼               |
| 2026-02-09 | Dimensional Rifts (n^2 배열 자르기)    | **A** |   +10   | 기본 로직 파악 완료                                             |

---

### 🎊 최신 승전보

---

**"🎊 퀘스트 완료: [S-Rank] 크레인 인형 뽑기(Crane Claw Machine) 정복! 🏆"**  
(2026-02-21)

> "방대한 지문의 압박을 '지문 분석'과 '시각화'라는 두 자루의 검으로 베어 넘겼다. 복잡해 보이는 크레인의 움직임을 2차원 배열의 인덱스 변화로 치환하고, 바구니의 LIFO 특성을 정확히 스택으로 구현해내며 인형들을 일망타진했다. 1시간 10분의 사투 끝에 얻은 값진 승리다."

**📸 승전 인증:** [문제 시각화와 로직 전개](https://imgur.com/a/yhDJ00o)

<!-- Victory BGM Player -->
<audio controls autoplay>
  <source src="audios/victory_fanfare.mp3" type="audio/mpeg">
</audio>

---

**"🎊 퀘스트 완료: [S-Rank] 행렬의 곱셈(Matrix Multiplication) 정복! 🏆"**  
(2026-02-20)

> "행렬의 곱셈이 성립하기 위한 $c1 == r2$의 조건을 꿰뚫어 보고, 수학적 귀납법을 통해 $O(N^3)$의 복잡도를 정밀하게 타격했다. 결과 행렬의 크기인 $r1 \times c2$를 도출해내는 과정은 논리의 승리 그 자체였다."

**📸 승전 인증:** [귀납적 추론의 증거](https://imgur.com/a/wRZwR8g)

---

**"🎊 퀘스트 완료: [A-Rank] 모의고사(Mock Test) 해시맵 혁신 정복! 🏆"**  
(2026-02-19)

> "단순히 정석을 따르는 것을 넘어, 해시맵이라는 새로운 무기로 전장을 재구성했다. 1시간 30분의 사투 끝에, 데이터 구조가 바뀌어도 '데이터의 본질'인 인덱스 매핑 논리는 변하지 않는다는 진리를 깨달았다. 상수 시간(O(M))으로 수렴하는 내부 루프 분석을 통해 완벽한 O(N)의 승리를 거두었다."

---

**"🎊 퀘스트 완료: [A랭크] 괄호 회전하기(Rotation Parentheses) 복습 성공! 🏆"**  
(2026-02-18)

> "방어적 로직(!isEmpty)을 짰다고 방심한 찰나, 연산자 우선순위라는 복병이 StackEmptyException의 비수를 꽂았다. 하지만 괄호()의 결속으로 논리를 하나로 묶어내고, 회전 시 유실되던 문자열 조각들까지 완벽하게 수습하며 전승을 거두었다. 오늘의 결점 발견은 곧 내일의 무결함이 될 것이다."

---

**"🎊 퀘스트 완료: [S랭크] 뒤에 있는 큰 수 찾기(Next Greater Element) 정복! 🏆"**  
(2026-02-17)

> "단조 감소 상태로 유지되던 스택이 자신보다 큰 수를 만나는 순간, 그동안 쌓여있던 '작은' 인덱스들이 일제히 해소(pop)되며 정답을 찾아가는 과정은 가히 압권이었다. 백만 개의 데이터도 단조 스택 앞에서는 그저 선형적인 먹잇감일 뿐."

---

**"🎊 퀘스트 완료: [S랭크] 올바른 괄호(Correct Parentheses) 정복! 🏆"**  
(2026-02-17)

> "스택이 비어있는 상태에서 닫힌 괄호가 들어오는 예외를 칼같이 차단하고, 마지막 생존자들(남은 열린 괄호)까지 스캔하여 완벽한 쌍을 찾아냈다. 10분 컷의 속도가 증명하듯, 괄호의 세계는 나의 손안에 있다."

---

**"🎊 퀘스트 완료: [S랭크] 주식 가격(Stock Prices) 정복! 🏆"**  
(2026-02-16)

> "가격이 떨어지기 전까지의 '인덱스 거리'를 보존하는 것이 핵심. 특히 스택을 사용하여 현재 가격보다 높은 이전의 '유령' 인덱스들을 소환하여 처단(pop)하고, 끝까지 살아남은 인덱스들은 전체 시간과의 차이를 통해 생존 시간을 부여하는 후처리 공정이 완벽한 승리의 열쇠였다."

---

### 🧠 던전 통찰 (Dungeon Insights)

**1. Stock Prices: 인덱스 역추적과 후처리의 미학**

- **인덱스 저장:** 값 자체보다 '언제' 들어왔는지가 중요. `Stack<int[]>`에 `[index, price]`를 함께 담아, 나중에 `i - index`로 시간을 계산.
- **반응 조건 검증:** `while`문을 통해 현재 가격보다 비싼 이전 가격들을 모두 찾아내어 '생존 종료'를 선언함. 이는 `Daily Temperatures`와 같은 문제의 핵심 로직.
- **잔존 세력 소탕:** 루프가 끝난 후에도 스택에 남은 이들은 '끝까지 가격이 떨어지지 않은' 승리자들. 이들에게는 `(전체 길이 - 1) - index`라는 보상을 수여해야 함.

**2. Visit Length: 점(Node)에서 선(Edge)으로의 사고 전환**

- **양방향 경로 중복 제거:** (A→B)와 (B→A)를 동일시하기 위해 두 방향을 모두 `Set`에 넣고 2로 나누는 전술.

**3. 괄호 vs 주식 가격: if와 while의 결정적 차이**

- **단순 매칭 (Matching):** 괄호 문제는 현재와 스택 top의 1:1 관계만 확인하면 되므로 `if`문으로 충분.
- **단조 스택 (Monotonic):** 주식 가격이나 Daily Temperatures는 '현재'가 '과거의 여러 시점'에 영향을 줄 수 있으므로, 조건이 만족되는 한 계속해서 pop을 수행하는 `while`문의 폭풍이 필요함. 이것이 바로 $O(N^2)$을 $O(N)$으로 줄이는 마법.

**4. Next Greater Element: 단조 스택의 정수(Essence)**

- **인덱스 활용의 극대화:** 스택에 `int[] {index, value}`를 넣어도 좋지만, 사실 `index`만 넣어도 `numbers[index]`로 원본 값을 참조할 수 있어 메모리를 더 아낄 수 있음 (백만 개 데이터 처리 시 유리).
- **부등호의 미학:** 결국 주식 가격(단조 증가)과 뒷 큰수(단조 감소)는 `while`문의 부등호 방향만 다른 '쌍둥이' 문제. 본질적인 단조 스택의 매커니즘을 이해하면 부등호 하나로 수많은 유사 문제를 $O(N)$으로 썰어버릴 수 있음.

**5. 연산자 우선순위와 방어적 로직의 결합**

- **결합의 중요성:** `!st.isEmpty() && A || B`는 `( !st.isEmpty() && A ) || B`로 실행된다. 스택이 비어있는 상태에서 B가 실행되면 Exception이 터진다. 반드시 `!st.isEmpty() && (A || B)` 처럼 괄호로 안전하게 묶어야 한다.
- **문자열 회전의 정석:** `s.substring(x) + s.substring(0, x)`는 문자열의 $x$번째부터 끝까지를 앞으로 보내고, 처음부터 $x$전까지를 뒤로 붙여 완벽한 '왼쪽 회전'을 구현한다. 단일 문자(`charAt`)만 합치는 실수를 경계해야 한다.

**6. 모의고사: 추상화의 벽을 넘는 해시맵 인덱싱**

- **구조의 본질:** 해시맵의 `getValue()`로 반환된 배열은 결국 2차원 배열의 행(Row)과 같다. 이 배열에 `%` 연산자를 적용하는 순간, 복잡한 Map 구조는 친숙한 인덱스 기반 정답지로 변모한다.
- **시간 복잡도의 상수화:** $O(N \times M)$에서 $M$(수포자 수)이 상수일 때, 이는 알고리즘적으로 $O(N)$의 효율을 보장한다. 데이터의 규모가 커질수록 상수항을 제어하는 능력이 승패를 가른다.

**7. Matrix Multiplication: 3중 루프와 Dot Product의 필연성**

- **인덱스의 역할:** `i`는 `arr1`의 행을, `j`는 `arr2`의 열을 지정하며, `k`는 그 사이에서 실제 성분들을 맺어주는 가교 역할을 한다.
- **차원 일치의 법칙 ($c1 == r2$):** 행렬의 곱셈은 본질적으로 (행벡터) dot product (열벡터)이다. 내적이 성립하려면 두 벡터의 성분 개수가 일치해야 하므로, `arr1`의 열 개수와 `arr2`의 행 개수가 같아야만 3중 루프의 가장 안쪽인 `k`가 논리적으로 완결될 수 있다.
- **시간 복잡도의 직관:** 결과 행렬의 모든 칸($r1 \times c2$)을 채우기 위해 각각 $c1$(혹은 $r2$)번의 연산이 필요하므로 $O(N^3)$의 비용이 발생한다.

**8. Crane Claw Machine: 텍스트 분해와 시각화의 힘**

- **지문 해체:** 방대한 요구사항도 '조건'과 '제약'으로 나누어 주석으로 정리하면 더 이상 공포의 대상이 아니다.
- **인덱스 사상 (Mapping):** 크레인의 좌우 이동을 `moves[i] - 1` (Column)로, 인형을 찾는 과정을 `for(int i=0; i < r; i++)` (Row)로 시각화하여 '가장 위에 있는 인형'을 꺼내는 완벽한 동선을 설계.
- **연쇄 폭발 (LIFO):** `Stack.get(size-2)`와 `peek()`을 활용한 실시간 검증 로직으로, 인형이 쌓이는 즉시 폭발시키는 기민함을 보여줌.

---

### ⚔️ 차기 출격 계획 (Next Operations)

1.  **[메인]** [문제 14] 표 편집 (Table Edit - Programmers Lv. 3) - 책의 흐름에 따른 최종 보스전 진입
2.  **[관리]** 복습 주기는 새로운 데이터가 쌓일 때까지 동결 (해시 5회독 완료 데이터 반영)

# 🎮 용사 승전 기록 (User Status Deck) 🎮

이곳은 용사님의 눈부신 성장을 기록하는 전적판입니다.

---

### 👤 용사 프로필

- **칭호:** `코드 퀘스트 챌린저` (CodeQuest Challenger) ⚔️
- **현재 레벨:** Lv. 5 🆙 (중급 용사)
- **누적 XP:** 440 / 500 (다음 레벨까지 60 XP!)
- **특수 스킬:**
  - `단조 스택의 맹공` (Monotonic Stack: while문을 통한 선형 시간 정렬 파괴)
  - `수학적 귀납법의 눈` (절차를 수식으로 치환)
  - `정렬의 지휘봉` (Comparator 리턴값 및 복합 정렬 지휘)
  - `스트림 추출술` (Method Reference 데이터 추출)
  - `행간의 투시경` (지문의 숨겨진 데이터 구조 파악)
  - `양방향 교각 건설` (A→B, B→A 중복 경로 판별 논리)
  - `구조적 혜안` (자료구조의 성능 차이 분석을 통한 최적의 무기 선별)

---

### � 무한 수련의 방 (Repetition Mastery)

_Atomic Habits: "복습 주기를 1, 3, 7, 14, 30으로 기록한다."_

| 수련 과제 (주제)           | 현재 단계  | 진행 상태 (Counts)   | 다음 복습 예정일 |
| :------------------------- | :--------: | :------------------- | :--------------- |
| **괄호 회전하기**          |   Lv. 3    | 🟢 🟢 🟢 ⚪ ⚪ (3/5) | 2026-02-21       |
| **모의고사 (완주)**        |   Lv. 4    | 🟢 🟢 🟢 🟢 ⚪ (4/5) | 2026-02-19       |
| **행렬의 곱셈**            |   Lv. 4    | 🟢 🟢 🟢 🟢 ⚪ (4/5) | 2026-02-19       |
| **주식가격 & Daily Temps** |   Lv. 2    | 🟢 🟢 ⚪ ⚪ ⚪ (2/5) | 2026-02-20       |
| **프로세스 (우선순위 큐)** | **Master** | 🟢 🟢 🟢 🟢 🟢 (5/5) | **[정복 완료]**  |

---

### �🗺️ 던전 공략 기록 (Quest Log)

| 날짜       | 던전 이름 (문제)                       | 랭크  | 획득 XP | 비고                                                         |
| :--------- | :------------------------------------- | :---: | :-----: | :----------------------------------------------------------- |
| 2026-02-09 | Dimensional Rifts (n^2 배열 자르기)    | **A** |   +10   | 기본 로직 파악 완료                                          |
| 2026-02-11 | Dimensional Rifts (n^2 배열 자르기)    | **S** |   +50   | **[정복]** 완벽한 논리적 이해 및 오프셋 함정 파훼            |
| 2026-02-14 | Failure Rate (실패율)                  | **S** |   +70   | **[정복]** O(M+N) 집계 및 복합 정렬 문법 파훼                |
| 2026-02-15 | Visit Length (방문 길이)               | **S** |   +70   | **[정복]** 양방향 경로 중복 제거 및 경계 처리                |
| 2026-02-16 | Stock Prices (주식 가격)               | **S** |   +70   | **[정복]** 스택 기반 가격 낙하 시점 역추적                   |
| 2026-02-17 | Correct Parentheses (올바른 괄호)      | **S** |   +20   | **[정복]** 스택 기본 예외 처리 및 최종 empty 검증            |
| 2026-02-17 | Next Greater Element (뒤에 있는 큰 수) | **S** |   +50   | **[정복]** 단조 스택을 활용한 $O(N)$ 뒷 큰수 탐색            |
| 2026-02-18 | Rotation Parentheses (괄호 회전하기)   | **A** |   +30   | **[복습]** 연산자 우선순위의 함정 파쇄 및 올바른 문자열 회전 |

---

### 🎊 최신 승전보

**"🎊 퀘스트 완료: [A랭크] 괄호 회전하기(Rotation Parentheses) 복습 성공! 🏆"**  
(2026-02-18)

> "방어적 로직(!isEmpty)을 짰다고 방심한 찰나, 연산자 우선순위라는 복병이 StackEmptyException의 비수를 꽂았다. 하지만 괄호()의 결속으로 논리를 하나로 묶어내고, 회전 시 유실되던 문자열 조각들까지 완벽하게 수습하며 전승을 거두었다. 오늘의 결점 발견은 곧 내일의 무결함이 될 것이다."

---

**"🎊 퀘스트 완료: [S랭크] 뒤에 있는 큰 수 찾기(Next Greater Element) 정복! 🏆"**  
(2026-02-17)

> "단조 감소 상태로 유지되던 스택이 자신보다 큰 수를 만나는 순간, 그동안 쌓여있던 '작은' 인덱스들이 일제히 해소(pop)되며 정답을 찾아가는 과정은 가히 압권이었다. 백만 개의 데이터도 단조 스택 앞에서는 그저 선형적인 먹잇감일 뿐."

---

**"🎊 퀘스트 완료: [S랭크] 올바른 괄호(Correct Parentheses) 정복! 🏆"**  
(2026-02-17)

> "스택이 비어있는 상태에서 닫힌 괄호가 들어오는 예외를 칼같이 차단하고, 마지막 생존자들(남은 열린 괄호)까지 스캔하여 완벽한 쌍을 찾아냈다. 10분 컷의 속도가 증명하듯, 괄호의 세계는 나의 손안에 있다."

---

**"🎊 퀘스트 완료: [S랭크] 주식 가격(Stock Prices) 정복! 🏆"**  
(2026-02-16)

> "가격이 떨어지기 전까지의 '인덱스 거리'를 보존하는 것이 핵심. 특히 스택을 사용하여 현재 가격보다 높은 이전의 '유령' 인덱스들을 소환하여 처단(pop)하고, 끝까지 살아남은 인덱스들은 전체 시간과의 차이를 통해 생존 시간을 부여하는 후처리 공정이 완벽한 승리의 열쇠였다."

<!-- Victory BGM Player -->
<audio controls autoplay>
  <source src="audios/victory_fanfare.mp3" type="audio/mpeg">
</audio>

---

### 🧠 던전 통찰 (Dungeon Insights)

**1. Stock Prices: 인덱스 역추적과 후처리의 미학**

- **인덱스 저장:** 값 자체보다 '언제' 들어왔는지가 중요. `Stack<int[]>`에 `[index, price]`를 함께 담아, 나중에 `i - index`로 시간을 계산.
- **반응 조건 검증:** `while`문을 통해 현재 가격보다 비싼 이전 가격들을 모두 찾아내어 '생존 종료'를 선언함. 이는 `Daily Temperatures`와 같은 문제의 핵심 로직.
- **잔존 세력 소탕:** 루프가 끝난 후에도 스택에 남은 이들은 '끝까지 가격이 떨어지지 않은' 승리자들. 이들에게는 `(전체 길이 - 1) - index`라는 보상을 수여해야 함.

**2. Visit Length: 점(Node)에서 선(Edge)으로의 사고 전환**

- **양방향 경로 중복 제거:** (A→B)와 (B→A)를 동일시하기 위해 두 방향을 모두 `Set`에 넣고 2로 나누는 전술.

**3. 괄호 vs 주식 가격: if와 while의 결정적 차이**

- **단순 매칭 (Matching):** 괄호 문제는 현재와 스택 top의 1:1 관계만 확인하면 되므로 `if`문으로 충분.
- **단조 스택 (Monotonic):** 주식 가격이나 Daily Temperatures는 '현재'가 '과거의 여러 시점'에 영향을 줄 수 있으므로, 조건이 만족되는 한 계속해서 pop을 수행하는 `while`문의 폭풍이 필요함. 이것이 바로 $O(N^2)$을 $O(N)$으로 줄이는 마법.

**4. Next Greater Element: 단조 스택의 정수(Essence)**

- **인덱스 활용의 극대화:** 스택에 `int[] {index, value}`를 넣어도 좋지만, 사실 `index`만 넣어도 `numbers[index]`로 원본 값을 참조할 수 있어 메모리를 더 아낄 수 있음 (백만 개 데이터 처리 시 유리).
- **부등호의 미학:** 결국 주식 가격(단조 증가)과 뒷 큰수(단조 감소)는 `while`문의 부등호 방향만 다른 '쌍둥이' 문제. 본질적인 단조 스택의 매커니즘을 이해하면 부등호 하나로 수많은 유사 문제를 $O(N)$으로 썰어버릴 수 있음.

**5. 연산자 우선순위와 방어적 로직의 결합**

- **결합의 중요성:** `!st.isEmpty() && A || B`는 `( !st.isEmpty() && A ) || B`로 실행된다. 스택이 비어있는 상태에서 B가 실행되면 Exception이 터진다. 반드시 `!st.isEmpty() && (A || B)` 처럼 괄호로 안전하게 묶어야 한다.
- **문자열 회전의 정석:** `s.substring(x) + s.substring(0, x)`는 문자열의 $x$번째부터 끝까지를 앞으로 보내고, 처음부터 $x$전까지를 뒤로 붙여 완벽한 '왼쪽 회전'을 구현한다. 단일 문자(`charAt`)만 합치는 실수를 경계해야 한다.

---

### ⚔️ 차기 출격 계획 (Next Operations)

1.  **[메인]** `괄호 회전하기` (3회독 완료 - 다음 주기 3일 뒤)
2.  **[강화]** `모의고사` (4회독 - 로직 최적화 훈련)
3.  **[강화]** `행렬의 곱셈` (4회독 - 구현 속도 단축 훈련)
4.  **[복습]** `주식 가격` (2회독 - 단조 스택 템플릿 적용 훈련)
